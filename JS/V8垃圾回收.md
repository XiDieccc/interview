# 垃圾回收策略

## 几个概念 

- `新生代`：`Scavenge算法`，`To空间`，`From空间`
- `老生代`：` 引用计数（循环引用）`，`标记清除(Mark-Sweep)`，`标记整理(Mark-Compact)` ，`增量标记`

## 新生代

- `Scavenge算法`将新生代内存分为两个`半空间` ： `From空间` 和 ` To空间`

- 对象首先分配到 Form空间中，在垃圾回收时，会根据该对象有无其他引用，来决定是否回收；**活跃状态的对象会被复制到To空间中**

- 然后在下一轮算法中，空着的From空间变为To空间，而To空间变为From空间，继续分配新的对象。

  

## 新生代晋升为老生代

两点：

- 该对象已经经历过了一次Scavenge算法
- To空间内存占用率已**超过25%**



## 老生代

之前采用的是 **引用计数** 的策略，但无法 解决 **循环引用** 的问题。



### Mark-Sweep 标记清除

- 垃圾回收器会在内部构建一个`根列表`，用于从根节点出发去寻找那些可以被访问到的变量。以下几种情况都可以作为根节点：（**解决了循环引用的问题**）
  - 全局对象
  - 本地函数的局部变量和参数
  - 当前嵌套调用链上的其他函数的变量和参数
- 然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。
- 最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。



### Mark-Compact 标记整理

 **解决了释放内存后造成的 不连续内存碎片问题**

- 将活跃的对象往堆内的一端进行移动



### 增量标记

减少垃圾回收带来的停顿时间，将一次标记全部 分为 多次标记。



# 优化问题

- 少创建**全局变量**，会被挂载到 window根节点上，使用完后 赋值为 **null** 。
- 手动清除 **定时器**
- 少用 **闭包**， 闭包返回的函数会被引用，而非销毁，导致其作用域无法被回收，以及其内部的局部变量 无法被销毁
- 清除 DOM 引用



参考文献

- https://juejin.cn/post/6844904016325902344#heading-6
- https://segmentfault.com/a/1190000020231307